"""
Write this amount of messages each answering a different
message in a public chat
"""
type AnswerInChatTask implements DailyTask {
  amount: Int!
}

"""
Post this amount of comments answering a newbie
with a level smaller than `max_level`
"""
type AnswerNewbieCommentTask implements DailyTask {
  amount: Int!

  maxLevel: Int!
}

"""
The `Boolean` scalar type represents `true` or `false`.
"""
scalar Boolean

"""
Post this amount of comments in a specific fandom
"""
type CommentInFandomTask implements DailyTask {
  amount: Int!

  fandomId: Int!
}

"""
Post this amount of comments under a post from
a newbie with a level smaller than `max_level`
"""
type CommentNewbiePostTask implements DailyTask {
  amount: Int!

  maxLevel: Int!
}

"""
Create and publish a post with a page of this type
"""
type CreatePostWithPageTypeTask implements DailyTask {
  amount: Int!

  pageType: PageType!
}

"""
Create and publish this amount of posts
"""
type CreatePostsTask implements DailyTask {
  amount: Int!
}

interface DailyTask {
  amount: Int!
}

"""
Details about a fandom's chance to appear
in a [`DailyTask`]
"""
type DailyTaskFandom {
  """
  Numeric ID of the fandom
  """
  fandomId: Int!

  """
  Relative chance that the fandom may appear

  This goes from `0.0` (exclusive) and up.
  """
  multiplier: Float!
}

"""
State of daily tasks for a user
"""
type DailyTaskInfo {
  """
  Amount of task units earned by the user

  If a user made 5 posts, the `progress`
  of a [`CreatePostsTask`] would be `5`.

  Note that this value can be higher than
  `total`.
  """
  progress: Int!

  """
  Total level count earned from doing daily
  tasks

  The last 3 daily tasks are recounted to
  account for cheating, the older tasks are
  just accepted as-is.
  """
  totalLevels: Int!

  """
  Bonus for having a lower level.
  This goes from `0.0` and up.

  This multiplier is *added* to `comboMultiplier`
  below, not actually multiplied.
  """
  levelMultiplier: Float!

  """
  Bonus for completing the task daily.
  This one goes from `1.0` and up.

  `comboMultiplier` is *added* to this value to
  result in the final multiplier.
  """
  comboMultiplier: Float!

  """
  Level count the user would receive if they
  complete the task in full.
  """
  possibleReward: Int!

  """
  Daily task's fandom name

  If the [`DailyTask`] involves a fandom, this
  contains its name.
  """
  fandomName: String

  """
  The daily task for today
  """
  task: DailyTask!
}

"""
Implement the DateTime<Utc> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

"""
Earn this amount of karma with anything
"""
type EarnAnyKarmaTask implements DailyTask {
  amount: Int!
}

"""
Earn this amount of karma with posts
"""
type EarnPostKarmaTask implements DailyTask {
  amount: Int!
}

"""
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
"""
scalar Float

scalar ID

"""
The `Int` scalar type represents non-fractional whole numeric values.
"""
scalar Int

"""
A scalar that can represent any JSON value.
"""
scalar JSON

"""
A scalar that can represent any JSON Object value.
"""
scalar JSONObject

"""
Legacy JSON notification
"""
type LegacyNotification {
  """
  Notification JSON
  """
  content: JSON!
}

"""
Legacy JSON notification
"""
input LegacyNotificationInput {
  """
  Notification JSON
  """
  content: JSON!
}

"""
The internal result of recount a user's level

It contains all the achievements and returns details about
each of them and the total level of a person.
"""
type LevelRecountResult {
  """
  The user's total level

  The minimum is 100. In UI, the level is shown
  as a 2-decimal number, so level `540` is `5.4`
  for the user.
  """
  totalLevel: Int!

  """
  Details about each achievement's progress

  The key of this map is the numeric ID of the
  achievement, and the value is details about
  that achievement.
  It is guaranteed that every achievement has
  a value in here.
  (In case it doesn't, just assume it's at zero.)
  """
  achievements: JSONObject!

  """
  The user whose level was recounted
  """
  user: User!
}

"""
Parameters for logging in via email
"""
input LoginEmailInput {
  """
  User's email address
  """
  email: String!

  """
  User's password
  """
  password: String!
}

union LoginResult = LoginResultSuccess|LoginResultTfaRequired

"""
Successful one-step login
"""
type LoginResultSuccess {
  """
  The access token
  """
  accessToken: String!

  """
  The refresh token
  """
  refreshToken: String!
}

"""
TFA is required to finish logging in
"""
type LoginResultTfaRequired {
  """
  Type of TFA required
  """
  tfaType: TfaType!

  """
  Token to request the status of the TFA flow
  """
  tfaWaitToken: String!
}

"""
Just enter the app
"""
type LoginTask implements DailyTask {
  amount: Int!
}

type Mutation {
  """
  Mark a user as logged in today
  """
  internalCheckIn(userId: ID!): Ok!

  """
  Change the name of a user
  """
  internalChangeName(userId: ID!, newName: String!): User!

  """
  Create a new account with email and password
  """
  registerEmail(input: RegisterEmailInput!): RegisterEmailResult!

  """
  Verify user's email after registration or deanonymizing
  """
  verifyEmail(token: String!): VerifyEmailResult!

  """
  Login via email and password
  """
  loginEmail(input: LoginEmailInput!): LoginResult!

  """
  Refresh the access token using the refresh token
  """
  loginRefresh(refreshToken: String!): LoginResultSuccess!

  """
  Log out. Terminate the current session
  """
  logout: Ok!

  """
  Resend verification email
  """
  resendVerification(email: String!): Ok!

  changePassword(oldPassword: String!, newPassword: String!): Ok!

  """
  Send an email with a password recovery link
  """
  sendPasswordRecovery(email: String!): Ok!

  """
  Use a recovery token to reset the password

  The recovery token is received from the email send
  by `send_password_recovery`
  """
  recoverPassword(token: String!, newPassword: String!): Ok!

  """
  Complete logging in via an external provider
  """
  loginOauth(input: OauthLoginInput!): OauthResult!

  """
  Bind an OAuth account to the current user
  """
  bindOauth(input: OauthLoginInput!): User!

  """
  Login as an internal service
  """
  loginInternal(key: String!): LoginResultSuccess!

  changeEmail(newEmail: String!): Ok!

  """
  Terminate an auth session
  """
  terminateSession(sessionId: ID!): ID!

  cancelEmailChange(token: String!): Ok!

  """
  Mark a single notification as read
  """
  readNotification(notificationId: ID!): Notification!

  """
  Mark every notification received by you as read
  """
  readAllNotifications: Ok!

  """
  Send a notification to a list of recipients
  """
  postNotification(input: NotificationInput!): Ok!

  """
  Set the notification token and type of the currently authenticated session

  A session can only have a single notification token.
  """
  setNotificationToken(tokenType: NotificationTokenType!, token: String!): Ok!
}

"""
A notification
"""
type Notification {
  """
  Notification payload
  """
  payload: NotificationPayload!

  """
  Time when notification was sent
  """
  createdAt: DateTime!

  """
  Whether notification has been read
  """
  read: Boolean!

  """
  Unique ID for this notification (unique across users)
  """
  id: ID!

  """
  User to whom this notification is directed
  """
  user: User!
}

input NotificationInput {
  recipients: [NotificationRecipient!]!

  payload: NotificationPayloadInput!

  ephemeral: Boolean!

  onlineOnly: Boolean!
}

union NotificationPayload = LegacyNotification

"""
Different types of notifications
"""
input NotificationPayloadInput {
  """
  Different types of notifications
  """
  legacy: LegacyNotificationInput
}

input NotificationRecipient {
  user: UserRecipient

  session: SessionRecipient
}

"""
Kinds of upstream services for sending notifications
"""
enum NotificationTokenType {
  """
  Firebase Cloud Messaging
  """
  FCM
}

"""
Parameters for logging in via OAuth

It is used in `login_oauth` and `bind_oauth`.
"""
input OauthLoginInput {
  """
  OAuth code issuer
  """
  provider: OauthProvider!

  """
  Unique nonce from [`OAuthUrl`]

  [`OAuthUrl`]: super::oauth_url::OAuthUrl
  """
  nonce: String!

  """
  The authorization code
  """
  code: String!
}

"""
An OAuth auth provider
"""
enum OauthProvider {
  """
  Old Firebase authentication method. Not actually OAuth
  """
  LEGACY_FIREBASE

  """
  `accounts.google.com`
  """
  GOOGLE
}

"""
Result of logging in via an OAuth provider
"""
type OauthResult {
  """
  `true` if there's a user with the same email
  but not OAuth provider account
  """
  emailAlreadyBound: Boolean!

  """
  If login is successful, tokens to log in
  """
  tokens: LoginResultSuccess
}

"""
Client information to log in with an OAuth provider

Get this with `oauth_url`
"""
type OauthUrl {
  """
  Full URL for the browser
  """
  url: String!

  """
  Requested scopes
  """
  scope: String!

  """
  Unique CSRF token from the URL
  """
  state: String!

  """
  Unique nonce from the URL
  """
  nonce: String!
}

"""
The string `"ok"`. That's it
"""
scalar Ok

enum PageType {
  TEXT

  IMAGE

  IMAGES

  LINK

  QUOTE

  SPOILER

  POLLING

  VIDEO

  TABLE

  DOWNLOAD

  CAMPFIRE_OBJECT

  USER_ACTIVITY

  LINK_IMAGE

  CODE
}

"""
User's base permission level
"""
enum PermissionLevel {
  """
  Regular user
  """
  USER

  """
  A member of highly trusted meta-staff
  """
  SUPERMOD

  """
  Highest ranking user
  """
  ADMIN

  """
  Internal system account
  """
  SYSTEM
}

"""
Post this amount of comments
"""
type PostCommentsTask implements DailyTask {
  amount: Int!
}

"""
Create and publish this amount of posts in a specific fandom
"""
type PostInFandomTask implements DailyTask {
  amount: Int!

  fandomId: Int!
}

type Query {
  """
  Force a recount of a user's level

  This method is for internal services only
  and you morons can't use it.
  """
  internalRecountLevel(userId: Int!): LevelRecountResult!

  """
  Get currently authenticated user
  """
  me: User!

  """
  Get the user that a recovery token changes password to
  """
  checkRecoveryToken(token: String!): User!

  """
  Get the necessary information to log in with an OAuth provider
  """
  oauthUrl(provider: OauthProvider!): OauthUrl!

  """
  Get the list of currently active sessions
  """
  activeSessions(offset: Int! = 0): [Session!]!

  """
  Get a [`User`] by their ID
  """
  userById(id: ID!): User

  """
  Get a [`User`] by their ID or username

  Since users can't have a username consisting only
  of digits,
  """
  userBySlug(slug: String!): User

  """
  List notifications received by you, newest first

  Use `before` for pagination, including the last notification's `created_at`.
  """
  notifications(before: DateTime, typeFilter: [Int!]): [Notification!]!
}

"""
Rate this amount of different publications
"""
type RatePublicationsTask implements DailyTask {
  amount: Int!
}

"""
Parameters for registering a new account with email
"""
input RegisterEmailInput {
  """
  Email address for the new account
  """
  email: String!

  """
  Password for the new account
  """
  password: String!
}

"""
New account registration result
"""
type RegisterEmailResult {
  """
  Access token for the user
  """
  accessToken: String!

  """
  Refresh token for the user
  """
  refreshToken: String!

  """
  Newly registered user
  """
  user: User!
}

"""
Various security settings of a [`User`]
"""
type SecuritySettings {
  """
  Whether this user has a Google account linked
  """
  googleLinked: Boolean!

  """
  Whether this user has been migrated from Firebase
  """
  firebaseLinked: Boolean!
}

type Session {
  """
  Whether the session is active and not expired
  """
  active: Boolean!

  """
  Last login_refresh call timestamp
  """
  lastActive: DateTime!

  """
  First login timestamp
  """
  createdAt: DateTime!

  """
  The session ID
  """
  id: ID!

  """
  Last IP that refreshed the session
  """
  ip: String

  """
  Full user agent string of the client that
  last refreshed the session
  """
  userAgent: String

  """
  Whether this is the currently authenticated session
  """
  current: Boolean!
}

input SessionRecipient {
  sessionId: Int!
}

"""
The `String` scalar type represents textual data, represented as UTF-8
character sequences. The String type is most often used by GraphQL to
represent free-form human-readable text.
"""
scalar String

"""
A two-factor authentication method
"""
enum TfaType {
  """
  The user should input a one-time code from
  their authenticator app.
  """
  TOTP

  """
  The user should visit a link from the email
  sent to their address.
  """
  EMAIL_LINK
}

"""
A user
"""
type User {
  """
  Unique nickname for the user
  """
  username: String!

  """
  Base permission level for the user
  """
  permissionLevel: PermissionLevel!

  """
  Account creation date
  """
  createdAt: DateTime!

  """
  User's ID

  Note that it is not guaranteed to be an
  integer.
  It should be treated as one only
  when another API requires it.
  """
  id: ID!

  """
  User's email

  The email is only visible to the user themselves and
  to supermods.
  """
  email: String

  """
  Get some security and login options for this user
  """
  securitySettings: SecuritySettings!

  """
  Get daily task information for this User
  """
  dailyTask: DailyTaskInfo!

  """
  Get fandoms this user is active in

  These fandoms have a chance of appearing in
  a daily task, their chance proportional to
  the `multiplier` field in [`DailyTaskFandom`].
  """
  dailyTaskFandoms: [DailyTaskFandom!]!
}

input UserRecipient {
  userId: Int!
}

type VerifyEmailResult {
  """
  Verified user
  """
  user: User!
}

"""
Write this amount of messages in a public chat
"""
type WriteMessagesTask implements DailyTask {
  amount: Int!
}

"""
A Directive provides a way to describe alternate runtime execution and type
validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution
behavior in ways field arguments will not suffice, such as conditionally
including or skipping a field. Directives provide this by describing
additional information to the executor.
"""
type __Directive {
  name: String!

  description: String

  locations: [__DirectiveLocation!]!

  args: [__InputValue!]!

  isRepeatable: Boolean!
}

"""
A Directive can be adjacent to many parts of the GraphQL language, a
__DirectiveLocation describes one such possible adjacencies.
"""
enum __DirectiveLocation {
  """
  Location adjacent to a query operation.
  """
  QUERY

  """
  Location adjacent to a mutation operation.
  """
  MUTATION

  """
  Location adjacent to a subscription operation.
  """
  SUBSCRIPTION

  """
  Location adjacent to a field.
  """
  FIELD

  """
  Location adjacent to a fragment definition.
  """
  FRAGMENT_DEFINITION

  """
  Location adjacent to a fragment spread.
  """
  FRAGMENT_SPREAD

  """
  Location adjacent to an inline fragment.
  """
  INLINE_FRAGMENT

  """
  Location adjacent to a variable definition.
  """
  VARIABLE_DEFINITION

  """
  Location adjacent to a schema definition.
  """
  SCHEMA

  """
  Location adjacent to a scalar definition.
  """
  SCALAR

  """
  Location adjacent to an object type definition.
  """
  OBJECT

  """
  Location adjacent to a field definition.
  """
  FIELD_DEFINITION

  """
  Location adjacent to an argument definition.
  """
  ARGUMENT_DEFINITION

  """
  Location adjacent to an interface definition.
  """
  INTERFACE

  """
  Location adjacent to a union definition.
  """
  UNION

  """
  Location adjacent to an enum definition.
  """
  ENUM

  """
  Location adjacent to an enum value definition.
  """
  ENUM_VALUE

  """
  Location adjacent to an input object type definition.
  """
  INPUT_OBJECT

  """
  Location adjacent to an input object field definition.
  """
  INPUT_FIELD_DEFINITION
}

"""
One possible value for a given Enum. Enum values are unique values, not a
placeholder for a string or numeric value. However an Enum value is returned
in a JSON response as a string.
"""
type __EnumValue {
  name: String!

  description: String

  isDeprecated: Boolean!

  deprecationReason: String
}

"""
Object and Interface types are described by a list of Fields, each of which
has a name, potentially a list of arguments, and a return type.
"""
type __Field {
  name: String!

  description: String

  args: [__InputValue!]!

  type: __Type!

  isDeprecated: Boolean!

  deprecationReason: String
}

"""
Arguments provided to Fields or Directives and the input fields of an
InputObject are represented as Input Values which describe their type and
optionally a default value.
"""
type __InputValue {
  name: String!

  description: String

  type: __Type!

  defaultValue: String
}

"""
A GraphQL Schema defines the capabilities of a GraphQL server. It exposes
all available types and directives on the server, as well as the entry
points for query, mutation, and subscription operations.
"""
type __Schema {
  """
  A list of all types supported by this server.
  """
  types: [__Type!]!

  """
  The type that query operations will be rooted at.
  """
  queryType: __Type!

  """
  If this server supports mutation, the type that mutation operations will
  be rooted at.
  """
  mutationType: __Type

  """
  If this server support subscription, the type that subscription
  operations will be rooted at.
  """
  subscriptionType: __Type

  """
  A list of all directives supported by this server.
  """
  directives: [__Directive!]!
}

"""
The fundamental unit of any GraphQL Schema is the type. There are many kinds
of types in GraphQL as represented by the `__TypeKind` enum.

Depending on the kind of a type, certain fields describe information about
that type. Scalar types provide no information beyond a name and
description, while Enum types provide their values. Object and Interface
types provide the fields they describe. Abstract types, Union and Interface,
provide the Object types possible at runtime. List and NonNull types compose
other types.
"""
type __Type {
  kind: __TypeKind!

  name: String

  description: String

  fields(includeDeprecated: Boolean! = false): [__Field!]

  interfaces: [__Type!]

  possibleTypes: [__Type!]

  enumValues(includeDeprecated: Boolean! = false): [__EnumValue!]

  inputFields: [__InputValue!]

  ofType: __Type

  specifiedByURL: String

  isOneOf: Boolean
}

"""
An enum describing what kind of type a given `__Type` is.
"""
enum __TypeKind {
  """
  Indicates this type is a scalar.
  """
  SCALAR

  """
  Indicates this type is an object. `fields` and `interfaces` are valid
  fields.
  """
  OBJECT

  """
  Indicates this type is an interface. `fields` and `possibleTypes` are
  valid fields.
  """
  INTERFACE

  """
  Indicates this type is a union. `possibleTypes` is a valid field.
  """
  UNION

  """
  Indicates this type is an enum. `enumValues` is a valid field.
  """
  ENUM

  """
  Indicates this type is an input object. `inputFields` is a valid field.
  """
  INPUT_OBJECT

  """
  Indicates this type is a list. `ofType` is a valid field.
  """
  LIST

  """
  Indicates this type is a non-null. `ofType` is a valid field.
  """
  NON_NULL
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include ("Included when true." if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip ("Skipped when true." if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

schema {
  query: Query
  mutation: Mutation
}
